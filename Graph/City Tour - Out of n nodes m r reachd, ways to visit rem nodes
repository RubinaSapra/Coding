//There are A cities numbered from 1 to A. You have already visited M cities, the indices of which are given in an array B of M integers.

If a city with index i is visited, you can visit either the city with index i-1 (i >= 2) or the city with index i+1 (i < A) if they are not already visited.
Eg: if N = 5 and array M consists of [3, 4], then in the first level of moves, you can either visit 2 or 5

#include<bits/stdc++.h>
using namespace std;

    long long nCr[1001][1001];
    long long ans = 1, p[1001];
    long mod = 1000000007;
    
int main()
{
	ios_base::sync_with_stdio(false);
	cout.tie(0); cin.tie(0);
	int n,m;
	cin>>n>>m;
	long long B[m];
	for(int i=0;i<m ; i++)
	cin>>B[i];

    for(int i=0;i<=n;i++)
    {
        for(int j= 0 ; j<=i; j++)
        {
            if(j==0 || j==i ) 
             nCr[i][j] = 1;
            else
             nCr[i][j] = (nCr[i-1][j-1] + nCr[i-1][j]) % mod;
        }
    }
    p[0] = 1, p[1] = 1;
    for(int i=2; i<=n; i++)
    p[i] = (p[i-1] * 2 ) % mod;
    sort(B,B+m);
    long long cnt=0, tmp;
    for(int i=0;i<m;i++){
        if(i==0) 
        tmp = B[i]-1;
        else
        {
            tmp = B[i] - B[i-1] - 1;
            ans = (ans * p[tmp]) % mod;
        }
        cnt+=tmp;
        ans = (ans*nCr[cnt][tmp]) % mod;
    }
    cnt+=n-B[m-1];
    ans =  ans*nCr[cnt][n-B[m-1]] %mod;
   cout<<ans;
}


